# Módulo Padrões de Projeto GoFs

## 1. Introdução
O primeiro trabalho de destaque relacionado a padrões de projeto em software foi em 1994 no livro “Design Patterns: Elements of Reusable Object-Oriented Software”, escrito por Erich Gamma, Richard Helm, Ralph Johnson e John Vlissides. Ele é um compilado de 23 padrões diferentes. Esse livro foi tão impactante que seus autores ficaram conhecidos como *Gang of Four* ou GoF daí o nome padrões GoFs.[1]

Surgiu com o objetivo de entregar soluções singulares para problemas comuns em um projeto de software. Eles são como plantas de obra já pré criadas que permite cutomização para resolver um problema de projeto recorrente no código. OS GoFs foram divididos em três categorias: Criacionais, Estruturais e Comportamentais. Segue abaixo dois exemplos de cada categoria.[2]

## 2. GoFs Criacionais
Os padrões criacionais têm o foco de aumentar a flexibilização e reutilização do código a partir de vários mecanismos de criação de objetos
### 2.1. Fábrica
O padrão Factory Method faz a sujestão de substituir chamadas diretas de construção de objetos por chamadas para um método fábrica especial ainda com o operador new a diferença agora é que esse operador está dentro do método da fábrica. Além disso, esses objetos que são retornados por um método fábrica normalmente denominam-se de produtos. Outro detalhe importante é que quem for utilizar o método de fábrica não identifica a diferença entre os produtos reais ou retornados por subclasses.[2]

<h6 align='center'>Figura 1: Estrutura do GoF de Fábrica<h6/>

<center>
<img width="600px" src="../assets/padroes_de_projeto/Gof_fabrica.png" alt="fabrica"> 
</center>

<h6 align='center'>Fonte: Refactoring Guru, [2]<h6/>

### 2.2. Construtor

Este padrão permite a construção de objetos complexos passo a passo. Ele permite a produção de diferentes objetos utilizando o mesmo código de construção. Essa construção de objetos é organizada em algumas ou várias etapas. A criação de um objeto é executada a partir de uma série de etapas em um objeto construtor. A vantagem que isso tras é apenas a chamada de etapas que são necessárias para a produção de uma configuração específica do objeto alvo.[2]

<h6 align='center'>Figura 2: Estrutura do GoF de Construtor<h6/>

<center>
<img width="400px" src="../assets/padroes_de_projeto/Gof_construtor.png" alt="construtor"> 
</center>

<h6 align='center'>Fonte: Refactoring Guru, [2]<h6/>

## 3. GoFs Estruturais

### 3.1. Decorador
Um decorador de estrutura é um padrão de design citado em "Gang of Four", uma coleção de padrões de design orientados a 
objetos que foram descritos pela primeira vez no livro "Design Patterns: Elements of Reusable Object-Oriented Software".
Um decorador de estrutura permite adicionar dinamicamente um novo comportamento a um objeto existente. Ele faz isso 
encapsulando o objeto original e delegando às chamadas de método a ele, enquanto fornece funcionalidade adicional
antes ou depois da chamada de método. Aqui está um exemplo de um decorador de estrutura em Python:

```python
class TextTag(object):
    def __init__(self, text):
        self._text = text

    def render(self):
        return self._text

class BoldWrapper(object):
    def __init__(self, wrapped):
        self._wrapped = wrapped

    def render(self):
        return "<b>{}</b>".format(self._wrapped.render())

class ItalicWrapper(object):
    def __init__(self, wrapped):
        self._wrapped = wrapped

    def render(self):
        return "<i>{}</i>".format(self._wrapped.render())

# Exemplo de uso
simple_hello = TextTag("Hello, World!")
special_hello = ItalicWrapper(BoldWrapper(simple_hello))
```

Este exemplo define uma classe TextTag que possui um método render que retorna o texto com o qual foi inicializado. 
Ele também define duas classes decoradoras, BoldWrapper e ItalicWrapper, que agrupam um objeto TextTag e adicionam tags
HTML em negrito e itálico ao texto renderizado, respectivamente. O objeto special_hello é criado envolvendo primeiro o 
objeto simple_hello com o BoldWrapper e, em seguida, agrupando o resultado com o ItalicWrapper. Quando o método render 
é chamado no objeto special_hello, a chamada é delegada ao objeto simple_hello agrupado, mas o texto retornado pelo 
método simple_hello.render() é circundado por tags HTML em negrito e itálico.

### 3.2. Composite
O padrão de projeto *composite* é um padrão de projeto estrutural que permite compor objetos em estruturas de árvore e 
tratá-los da mesma forma que objetos individuais. O padrão de design *composite* é usado para representar hierarquias 
parte-todo de objetos.

Aqui está um exemplo do padrão de design composto em Python:

```python
class Graphic(object):
    def render(self):
        raise NotImplementedError()

class CompositeGraphic(Graphic):
    def __init__(self):
        self._graphics = []

    def render(self):
        for graphic in self._graphics:
            graphic.render()

    def add(self, graphic):
        self._graphics.append(graphic)

    def remove(self, graphic):
        self._graphics.remove(graphic)

class Ellipse(Graphic):
    def __init__(self, name):
        self._name = name

    def render(self):
        print("Ellipse: {}".format(self._name))

# Example usage
g1 = Ellipse("1")
g2 = Ellipse("2")
g3 = Ellipse("3")
g4 = Ellipse("4")

graphic = CompositeGraphic()
graphic1 = CompositeGraphic()
graphic2 = CompositeGraphic()

graphic1.add(g1)
graphic1.add(g2)
graphic1.add(g3)

graphic2.add(g4)

graphic.add(graphic1)
graphic.add(graphic2)

graphic.render()
```

Neste exemplo, a classe Graphic é uma classe abstrata que possui um método render. A classe CompositeGraphic é uma 
implementação concreta da classe Graphic que pode conter outros objetos Graphic. A classe Ellipse é uma implementação 
concreta da classe Graphic que representa uma elipse. O objeto *graphic* é um objeto composto que contém dois objetos 
compostos, *graphic1* e *graphic2*, que por sua vez contêm objetos 'Ellipse' individuais. Quando o método render é 
chamado no objeto gráfico, ele delega a chamada ao método render de cada um de seus objetos filhos, o que resulta na 
renderização de todas as elipses.

## 4. GoFs Comportamentais

### 4.1. Template Method

### 4.2. Iterator

## 5. Referências
[1] Tedesco Kennedy. Padrões de projeto: o que são e o que resolvem. Disponível em <https://www.treinaweb.com.br/blog/padroes-de-projeto-o-que-sao-e-o-que-resolvem/>, acesso em 06/01/2023.

[2] Refactoring Guru. Padrões de Projeto. Disponível em <https://refactoring.guru/pt-br/design-patterns>, acesso em 04/01/2023.

[3] Python Brasil. Decoradores_Python_(Python_Decorators). Disponível em <https://wiki.python.org.br/Decoradores_Python_(Python_Decorators)>, acesso em 05/01/2023.

[4] Python Decorator Library. Disponível em <https://wiki.python.org/moin/PythonDecoratorLibrary>, acesso em 05/01/2023.

[5] Jones Roberto. Design Patterns -- Parte 10 -- Composite. Disponível em <https://medium.com/xp-inc/desing-patterns-parte-10-composite-f7600cb3aad7>, acesso em 05/01/2023.

## Versionamento
| Versão | Mensagem                      | Autor          | Data       |
|--------|-------------------------------|----------------|------------|
| 1.0    | Criação do Documento          | Rafael Pereira | 05/01/2023 |
| 1.1    | Introdução e GoFs Criacionais | Rafael         | 06/01/2023 |
| 1.2    | Adicionando GoFs Estruturais  | Paulo Gontijo  | 06/01/2023 |